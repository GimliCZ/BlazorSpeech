let controller=null;class SpeechController{constructor(){this.synth=window.speechSynthesis,this.voices=null,this.disposed=!1,this._init()}_init(){const e=this.synth.getVoices();if(e&&e.length>0)return this.voices=e,void(this.voiceReady=Promise.resolve());this.voiceReady=new Promise((e=>{const t=()=>{const s=this.synth.getVoices();s&&s.length>0&&(this.voices=s,this.synth.removeEventListener("voiceschanged",t),e())};this.synth.addEventListener("voiceschanged",t)}))}async ensureVoices(){this.voices&&this.voices.length>0||this.voiceReady&&await this.voiceReady}speak(e){if(this._throwIfDisposed(),!e||!e.text)return;this.synth.cancel();const t=new SpeechSynthesisUtterance(e.text);if(e.lang&&(t.lang=e.lang),"number"==typeof e.rate&&(t.rate=e.rate),"number"==typeof e.pitch&&(t.pitch=e.pitch),"number"==typeof e.volume&&(t.volume=e.volume),e.voice){const s=this._findVoice(e.voice,e.lang);s&&(t.voice=s)}this.synth.speak(t)}stop(){this._throwIfDisposed(),this.synth.cancel()}isSpeaking(){return!this.disposed&&(this.synth.speaking||this.synth.pending)}async getVoices(){return this._throwIfDisposed(),await this.ensureVoices(),this.voices?this.voices.map((e=>({name:e.name,lang:e.lang,voiceUri:e.voiceURI,isDefault:e.default,isLocalService:e.localService}))):[]}dispose(){this.disposed||(this.disposed=!0,this.synth.cancel(),this.voices=null,this.voiceReady=null)}_findVoice(e,t){if(!this.voices)return null;let s=this.voices.find((t=>t.name===e));return s||(t?this.voices.find((e=>e.lang===t))??null:null)}_throwIfDisposed(){if(this.disposed)throw new Error("SpeechController disposed")}}function getController(){return controller||(controller=new SpeechController),controller}export function speak(e){getController().speak(e)}export function stop(){getController().stop()}export function isSpeaking(){return getController().isSpeaking()}export async function getVoices(){return await getController().getVoices()}export function dispose(){controller&&(controller.dispose(),controller=null)}