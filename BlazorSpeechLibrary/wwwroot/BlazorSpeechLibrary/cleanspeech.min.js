let controller=null;class SpeechController{constructor(){this.synth=window.speechSynthesis,this.voices=null,this._voicesChangedHandler=null,this.voiceReady=null,this._stateChangeCallbacks=[],this._currentUtterance=null,this.disposed=!1,this._init()}_init(){const e=this.synth.getVoices();if(e&&e.length>0)return this.voices=e,void(this.voiceReady=Promise.resolve());this.voiceReady=new Promise((e=>{this._voicesChangedHandler=()=>{const t=this.synth.getVoices();t&&t.length>0&&(this.voices=t,this._removeVoicesChangedListener(),e())},this.synth.addEventListener("voiceschanged",this._voicesChangedHandler)}))}_removeVoicesChangedListener(){this._voicesChangedHandler&&(this.synth.removeEventListener("voiceschanged",this._voicesChangedHandler),this._voicesChangedHandler=null)}async ensureVoices(){this.voices&&this.voices.length>0||this.voiceReady&&await this.voiceReady}speak(e){if(this._throwIfDisposed(),!e||!e.text)return;e.queue||(this.synth.cancel(),this._cleanupCurrentUtterance());const t=new SpeechSynthesisUtterance(e.text);if(e.lang&&(t.lang=e.lang),"number"==typeof e.rate&&(t.rate=e.rate),"number"==typeof e.pitch&&(t.pitch=e.pitch),"number"==typeof e.volume&&(t.volume=e.volume),e.voice){const n=this._findVoice(e.voice,e.lang);n&&(t.voice=n)}t.onstart=()=>this._notifySpeakingState(!0),t.onend=()=>{this._notifySpeakingState(!1),this._cleanupCurrentUtterance()},t.onerror=()=>{this._notifySpeakingState(!1),this._cleanupCurrentUtterance()},this._currentUtterance=t,this.synth.speak(t)}cancel(){this._throwIfDisposed(),this.synth.cancel(),this._cleanupCurrentUtterance(),this._notifySpeakingState(!1)}pause(){this._throwIfDisposed(),this.synth.pause(),this._notifySpeakingState(!1)}resume(){this._throwIfDisposed(),this.synth.resume(),this._notifySpeakingState(!0)}getPaused(){return!this.disposed&&this.synth.paused}getPending(){return!this.disposed&&this.synth.pending}getSpeaking(){return!this.disposed&&this.synth.speaking}isSpeaking(){return!this.disposed&&(this.synth.speaking||this.synth.pending)}async getVoices(){return this._throwIfDisposed(),await this.ensureVoices(),this.voices?this.voices.map((e=>({name:e.name,lang:e.lang,voiceUri:e.voiceURI,isDefault:e.default,isLocalService:e.localService}))):[]}dispose(){this.disposed||(this.disposed=!0,this._cleanupCurrentUtterance(),this._removeVoicesChangedListener(),this.synth.cancel(),this.voices=null,this.voiceReady=null,this.synth=null)}_cleanupCurrentUtterance(){this._currentUtterance&&(this._currentUtterance.onstart=null,this._currentUtterance.onend=null,this._currentUtterance.onerror=null,this._currentUtterance=null)}_notifySpeakingState(e){if(!this.disposed)for(const t of this._stateChangeCallbacks)try{t(e)}catch(e){console.error("Error in speaking state callback:",e)}}onSpeakingStateChanged(e){if(this._throwIfDisposed(),"function"!=typeof e)throw new Error("Callback must be a function");return this._stateChangeCallbacks.push(e),()=>{const t=this._stateChangeCallbacks.indexOf(e);-1!==t&&this._stateChangeCallbacks.splice(t,1)}}_findVoice(e,t){if(!this.voices)return null;let n=this.voices.find((t=>t.name===e));return n||(t?this.voices.find((e=>e.lang===t))??null:null)}_throwIfDisposed(){if(this.disposed)throw new Error("SpeechController disposed")}}function getController(){return controller||(controller=new SpeechController),controller}export function speak(e){getController().speak(e)}export function cancel(){getController().cancel()}export function pause(){getController().pause()}export function resume(){getController().resume()}export function isSpeaking(){return getController().isSpeaking()}export function getPaused(){return getController().getPaused()}export function getPending(){return getController().getPending()}export function getSpeaking(){return getController().getSpeaking()}export async function getVoices(){return await getController().getVoices()}export function dispose(){controller&&(controller.dispose(),controller=null)}export async function onSpeakingStateChanged(e,t){const n=async n=>{try{await e.invokeMethodAsync(t,n)}catch(e){console.error("Error invoking .NET callback:",e)}};return{callback:n,unsubscribe:getController().onSpeakingStateChanged(n)}}export function unsubscribeFromSpeakingState(e){e&&"function"==typeof e.unsubscribe&&e.unsubscribe()}